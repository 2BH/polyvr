<?xml version="1.0" encoding="UTF-8"?>
<Scene name_suffix="0" base_name="nature" name_space="Scene" loading_time="495">
  <Objects>
    <Object base_name="Root" name_space="__global__" name_suffix="0" persistency="666" pickable="0" type="Object" unique="1" visible="1">
      <Object ambient="0.3 0.3 0.3 1" base_name="Headlight" beacon="Headlight_beacon" diffuse="1 1 1 1" lightType="point" name_space="__global__" name_suffix="0" on="1" persistency="666" pickable="0" shadow="0" shadowColor="0.1 0.1 0.1 1" shadowType="4096" specular="0.1 0.1 0.1 1" type="Light" unique="1" visible="1">
        <Object accept_root="1" aspect="1" at="0 1 0" at_dir="0" base_name="Default" far="250" fov="1.0472" from="2.88263 3.19597 3.93626" name_space="__global__" name_suffix="0" near="0.01" persistency="666" pickable="0" scale="1 1 1" type="Camera" unique="1" up="0 1 0" visible="1">
          <Object at="0 0 -1" at_dir="1" base_name="Headlight_beacon" from="0 0 0" light="Headlight" name_space="__global__" name_suffix="0" persistency="666" pickable="0" scale="1 1 1" type="LightBeacon" unique="1" up="0 1 0" visible="1">
            <constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/>
          </Object>
          <constraint active="1" cR="0 1 0" cR_local="0" cR_mode="0" cT="0 1 0" cT_local="0" cT_mode="0" persistency="666"/>
        </Object>
      </Object>
    </Object>
  </Objects>
  <Rendering deferred_rendering="0" frustum_culling="1" hmdd="0" occlusion_culling="0" persistency="666" ssao="0" ssao_kernel="4" ssao_noise="4" ssao_radius="0.02" two_sided="1"/>
  <Scripts persistency="666">
    <Script base_name="init" name_space="__script__" name_suffix="0" persistency="666" unique="1" type="Python" mobile="">
      <core>
	import VR
	from random import random
	
	r = VR.getRoot().find('Headlight')

	if hasattr(VR, 'tree'): VR.tree.destroy()
	VR.tree = VR.Tree()
	r.addChild(VR.tree)
	
	#VR.tree.setup(6,5,int(random()*100), 0.2,0.5,0.78,0.45, 0.2,0.4,0.2,0.2)
	VR.tree.setup(4,4,int(random()*100), 0.2,0.5,0.78,0.45, 0.2,0.4,0.2,0.2)
	
	VR.tree.setPatchVertices(2)
	types = [ 'GL_PATCHES' for t in VR.tree.getTypes() ]
	VR.tree.setTypes(types)
	m = VR.Material('treemat123')
	VR.tree.setMaterial(m)
	
	m.setVertexProgram('shrd_vert')
	m.setFragmentProgram('shrd_frag')
	#m.setFragmentProgram('shdr_s_f')
	m.setTessControlProgram('shdr_tc')
	m.setTessEvaluationProgram('shdr_te')
	m.setGeometryProgram('shrd_geo')
	#m.setGeometryProgram('shdr_s_g')
	
	m.enableShaderParameter('OSGCameraPosition')	
	m.setWireFrame(0)
	m.setLineWidth(3)
	
	tg = VR.TextureGenerator()
	tg.setSize(50,50,50)
	
	tg.add('Perlin', 1, [0.7,0.5,0.3], [1,0.9,0.7])
	tg.add('Perlin', 1.0/4, [1,0.9,0.7], [0.7,0.5,0.3])
	m.setTexture(tg.compose(0))
	
	
	
	
</core>
      <trig type="on_device" dev="keyboard" state="Pressed" param="" key="105" name_suffix="0" base_name="trigger" name_space="__global__"/>
      <trig type="on_scene_load" dev="" state="Pressed" param="" key="0" name_suffix="7" base_name="trigger" name_space="__global__"/>
    </Script>
    <Script base_name="shdr_s_f" name_space="__script__" name_suffix="0" persistency="666" unique="1" type="GLSL" mobile="">
      <core>
#version 120

void main( void ) {
	gl_FragColor = vec4(1.0);
}
</core>
    </Script>
    <Script base_name="shdr_s_g" name_space="__script__" name_suffix="0" persistency="666" unique="1" type="GLSL" mobile="">
      <core>
#version 400 compatibility&#13;
#extension GL_EXT_geometry_shader4 : enable&#13;
layout (lines) in;&#13;
layout (triangle_strip, max_vertices = 24) out;&#13;
in vec2 tc[];
&#13;
//Phong&#13;
out vec3 ViewDirection;&#13;
out vec3 fvObjectPosition;
out vec3 MVPos;
out vec3 Normal;
out vec3 TexCoord;

out float cylR1;
out float cylR2;
out vec3 cylDir;
out vec3 cylP0;
out vec3 cylP1;
out vec3 cylN0;
out vec3 cylN1;

uniform vec3 OSGCameraPosition;

in mat4 mMVv[];
in mat4 mPv[];

#define mMVP mPv[0]*mMVv[0]
#define mMV mMVv[0]
#define mP mPv[0]
&#13;
//PHONG-----------------&#13;
void addPhongVars(vec4 p) {&#13;
   MVPos = vec3(mMV*p);
   fvObjectPosition = vec3(mMVP*p);&#13;
   ViewDirection = -fvObjectPosition.xyz;
   ViewDirection = normalize(ViewDirection);
   &#13;
   /*vec4 p1 = gl_PositionIn[0];&#13;
   vec4 p2 = gl_PositionIn[1];
   vec3 d = normalize(p2.xyz - p1.xyz);
   TexCoord = p.xyz + 0.5 * d / (1.0+10*p.xyz);*/
   
   TexCoord = p.xyz;
   TexCoord.y *= 0.15;&#13;
}
&#13;
void emitTriangle(vec4 p1, vec4 p2, vec4 p3) {&#13;
   gl_Position = gl_ModelViewProjectionMatrix*p1;&#13;
   addPhongVars(p1);&#13;
   EmitVertex();&#13;
   gl_Position = gl_ModelViewProjectionMatrix*p2;&#13;
   addPhongVars(p2);&#13;
   EmitVertex();&#13;
   gl_Position = gl_ModelViewProjectionMatrix*p3;&#13;
   addPhongVars(p3);&#13;
   EmitVertex();&#13;
   EndPrimitive();&#13;
}&#13;
&#13;
void emitQuad(vec4 p1, vec4 p2, vec4 p3, vec4 p4) {&#13;
   emitTriangle(p1, p2, p4);&#13;
   emitTriangle(p2, p4, p3);&#13;
}&#13;
&#13;
void emitSimpleQuad(vec4 pos[4]) {&#13;
   emitQuad(pos[0], pos[1], pos[2], pos[3]);&#13;
}
&#13;
float Sign(in float x) {
    return step(0, x)*2 - 1;
}

vec3 getOffsets() {
   vec3 d = OSGCameraPosition - gl_PositionIn[1].xyz;
   return vec3(Sign(d[0]), Sign(d[1]), Sign(d[2]));
}

void main() {&#13;
   vec4 p1 = gl_PositionIn[0];&#13;
   vec4 p2 = gl_PositionIn[1];
   
   cylR1 = tc[0][0]*0.05;
   cylR2 = tc[1][0]*0.05;
   cylDir = normalize(vec3(mMV * vec4(p2.xyz - p1.xyz,0.0)));
   //cylDir = vec3(mMV * vec4(normalize(p1.xyz - p2.xyz),0.0));
   cylP0 = vec3(mMV * p1);
   cylP1 = vec3(mMV * p2);
   cylN0 = vec3(mMV * vec4(0.0,1.0,0.0,0.0));
   cylN1 = vec3(mMV * vec4(0.0,1.0,0.0,0.0));
   &#13;
   gl_FrontColor = vec4(0.6, 0.6, 0.3, 1.0);&#13;

   vec3 offs = getOffsets();&#13;
   vec4 pos[4];
   float S1x = 0.05*offs.x;
   float S2x = -0.05*offs.x;
   float S1y = 0.05*offs.z;
   float S2y = -0.05*offs.z;
   
   
   //emitTriangle(gl_PositionIn[0], gl_PositionIn[1], gl_PositionIn[1]);
   
   &#13;
   pos[0] = p1+vec4(S1x,0,S1y,0)*tc[0][0];&#13;
   pos[1] = p2+vec4(S1x,0,S1y,0)*tc[1][0];&#13;
   pos[2] = p2+vec4(S2x,0,S1y,0)*tc[1][0];&#13;
   pos[3] = p1+vec4(S2x,0,S1y,0)*tc[0][0];&#13;
   emitSimpleQuad(pos);&#13;
&#13;
   pos[0] = p2+vec4(S1x,0,S1y,0)*tc[1][0];&#13;
   pos[1] = p1+vec4(S1x,0,S1y,0)*tc[0][0];&#13;
   pos[2] = p1+vec4(S1x,0,S2y,0)*tc[0][0];&#13;
   pos[3] = p2+vec4(S1x,0,S2y,0)*tc[1][0];&#13;
   emitSimpleQuad(pos);
   
   vec4 pc = p1;
   float R = tc[0][0];
   if (offs.y &gt; 0) { pc = p2; R = tc[1][0]; }&#13;
   pos[0] = pc+vec4(S1x,0,S1y,0)*R;&#13;
   pos[1] = pc+vec4(S2x,0,S1y,0)*R;&#13;
   pos[2] = pc+vec4(S2x,0,S2y,0)*R;&#13;
   pos[3] = pc+vec4(S1x,0,S2y,0)*R;&#13;
   emitSimpleQuad(pos);
}
</core>
    </Script>
    <Script base_name="shdr_tc" name_space="__script__" name_suffix="0" persistency="666" unique="1" type="GLSL" mobile="">
      <core>
#version 400 compatibility
#extension GL_ARB_tessellation_shader : enable

layout(vertices = 2) out;
out vec3 tcPosition[];
in vec2 vtc[];
out vec2 ctc[];
in vec3 vn[];
out vec3 cn[];

#define ID gl_InvocationID

void main() {
    tcPosition[ID] = gl_in[ID].gl_Position.xyz;
    ctc[ID] = vtc[ID];
    cn[ID] = vn[ID];
    
    if (ID == 0) {
        gl_TessLevelOuter[0] = 1;
        gl_TessLevelOuter[1] = 4;
    }
}
</core>
    </Script>
    <Script base_name="shdr_te" name_space="__script__" name_suffix="0" persistency="666" unique="1" type="GLSL" mobile="">
      <core>
#version 400 compatibility
#extension GL_ARB_tessellation_shader : enable

layout( isolines ) in;
in vec3 tcPosition[];
in vec2 ctc[];
in vec3 cn[];
out vec2 tc;

void main() {
    float u = gl_TessCoord.x;
     
    vec3 n1 = cn[0];
    vec3 n2 = cn[1];
    vec3 p1 = tcPosition[0];
    vec3 p2 = p1+n1*0.1;
    vec3 p3 = tcPosition[1];
    
    vec3 pos = (1-u)*(1-u)*p1 + 2*(1-u)*u*p2 + u*u*p3;
    
    tc = mix(ctc[0], ctc[1], u);
    gl_Position = vec4(pos, 1);
}
</core>
    </Script>
    <Script base_name="shrd_frag" name_space="__script__" name_suffix="0" persistency="666" unique="1" type="GLSL" mobile="">
      <core>
#version 400 compatibility

vec4 fvAmbient  = vec4(0.36, 0.36, 0.36, 1.0);&#13;
//vec4 fvSpecular = vec4(0.7,  0.7,  0.7,  1.0);&#13;
vec4 fvSpecular = vec4(0.3,  0.3,  0.3,  1.0);&#13;
vec4 fvDiffuse  = vec4(0.5,  0.5,  0.5,  1.0);&#13;
//float fSpecularPower = 25.0;&#13;
float fSpecularPower = 10.0;&#13;
&#13;
uniform sampler3D tex;&#13;

in float cylR1;
in float cylR2;
in vec3 cylDir;
in vec3 cylP0;
in vec3 cylP1;
in vec3 cylN0;
in vec3 cylN1;
&#13;
in vec3 ViewDirection;&#13;
in vec3 fvObjectPosition;
in vec3 MVPos;
in vec3 Normal;
in vec3 TexCoord;

vec3 norm;

#define eps 0.0001

vec2 solveEq(float A, float B, float C) {
   	float D = B*B-4.0*A*C;
   	if (D &lt; 0.0) discard; // no solution/intersection
   	D = sqrt(D);
   	float t1 = (-B+D)/A*0.5;
   	float t2 = (-B-D)/A*0.5;
   	//if (t1 &lt; 0) return t2;
   	//if (t2 &lt; 0) return t1;
   	return vec2(t1, t2);
}

float intersectCap(vec3 rayStart, vec3 rayDir, vec3 p0, vec3 n, float r) {
	float t = dot((p0-rayStart),n)/dot(rayDir,n);
   	vec3 p = rayStart + t*rayDir;
   	if ( abs(dot(n, p-p0)) &gt; eps ) return -1;
   	if ( distance(p,p0) &gt; r ) return -1;
   	return t;
}

// ellipsoid: (x/a)2 + (y/b)2 + (z/c)2 = 1
vec3 applyCaps(vec3 rayStart, vec3 rayDir, float tp) {
   	vec3 pC = rayStart + tp*rayDir;
   	if ( dot(cylN0, pC-cylP0) &lt; -eps ) {
   		float tc0 = intersectCap(rayStart, rayDir, cylP0, cylN0, cylR1);
   		if (tc0 &gt; eps) {
   			tp = max( tp, tc0 );
   			pC = rayStart + tp*rayDir;
   		} else discard;
   	}
   	
   	if ( dot(cylN1, pC-cylP1) &gt;  eps )  {
   		float tc1 = intersectCap(rayStart, rayDir, cylP1, cylN1, cylR2);
   		if (tc1 &gt; eps) {
   			tp = max( tp, tc1 );
   			pC = rayStart + tp*rayDir;
   		} else discard;
   	}
   	return pC;
}

vec3 raycastCylinder(vec3 rayStart, vec3 rayDir) {
   	vec3 rayDRad = rayDir - dot(rayDir, cylDir)*cylDir;
   	vec3 rayPRad = rayStart-cylP0 - dot(rayStart-cylP0, cylDir)*cylDir;
   	
   	float A = dot(rayDRad,rayDRad);
   	float B = 2.0*dot(rayDRad, rayPRad);
   	float C = dot(rayPRad, rayPRad) - cylR1*cylR1;
   	vec2 t = solveEq(A, B, C);
   	float tp = min(t[0],t[1]);
   	return applyCaps(rayStart, rayDir, tp);
}

vec3 raycastCone(vec3 rayStart, vec3 rayDir) {
   	float H = distance(cylP0, cylP1);
   	float H2 = H*H;
   	float dR = cylR1-cylR2;
   	float dR2 = dR*dR;
   	
   	if (abs(dR) &lt; eps) return raycastCylinder(rayStart, rayDir);
   	//return fvObjectPosition;
   	
   	vec3 cylPa = cylP0 + cylDir * cylR1*H/dR;
   	float vrvc = dot(rayDir, cylDir);
   	float dpvc = dot(rayStart-cylPa, cylDir);
   	vec3 rayDRad = rayDir - vrvc*cylDir;
   	vec3 rayPRad = rayStart-cylPa - dpvc*cylDir;
   	float cos2a = H2 / (H2 + dR2);
   	float sin2a = 1.0 - cos2a;
   	
   	float A = cos2a * dot(rayDRad,rayDRad) - sin2a * vrvc * vrvc;
   	float B = 2.0 * (cos2a * dot(rayDRad, rayPRad) - sin2a * vrvc * dpvc);
   	float C = cos2a * dot(rayPRad, rayPRad) - sin2a * dpvc * dpvc;
   	vec2 t = solveEq(A, B, C);
   	float tp = min(t[0],t[1]);
   	return applyCaps(rayStart, rayDir, tp);
}
&#13;
void main( void ) {
	norm = Normal;
   	vec3 rayStart = vec3(0.0);
   	vec3 rayDir = MVPos;
   	rayDir = normalize(rayDir);
   	
	vec3 pC = fvObjectPosition;
	pC = raycastCone(rayStart, rayDir);
   	norm = pC - cylP0 - dot(pC - cylP0, cylDir)*cylDir;
   	norm = normalize(norm);&#13;

	mat4 miMV = inverse( gl_ModelViewMatrix ); // TODO: avoid computing inverse here!
	vec3 tc = (miMV*vec4(pC, 1.0)).xyz*10;
	tc.y *= 0.25;

	vec3  fvNormal         = normalize( norm );&#13;
	vec3  fvLightDirection = normalize( gl_LightSource[0].position.xyz - pC.xyz);
	float fNDotL           = dot( fvNormal, fvLightDirection );&#13;
	vec3  fvReflection     = normalize( ( ( 2.0 * fvNormal ) * fNDotL ) - fvLightDirection );&#13;
	vec3  fvViewDirection  = normalize( ViewDirection );&#13;
	float fRDotV           = max( 0.0, dot( fvReflection, fvViewDirection ) );&#13;
	vec4  fvBaseColor      = texture(tex, tc);&#13;
	vec4  fvTotalAmbient   = fvAmbient * fvBaseColor;&#13;
	vec4  fvTotalDiffuse   = fvDiffuse * fNDotL * fvBaseColor;&#13;
	vec4  fvTotalSpecular  = fvSpecular * ( pow( fRDotV, fSpecularPower ) );&#13;
	gl_FragColor = fvTotalAmbient + fvTotalDiffuse + fvTotalSpecular;

	// TODO: set depth buffer&#13;
}




</core>
    </Script>
    <Script base_name="shrd_geo" name_space="__script__" name_suffix="0" persistency="666" unique="1" type="GLSL" mobile="">
      <core>
//----------------------------------------------------------------------------------------------MAIN--GP&#13;
#version 400 compatibility&#13;
#extension GL_EXT_geometry_shader4 : enable&#13;
layout (lines) in;&#13;
layout (triangle_strip, max_vertices = 12) out;&#13;
in vec2 tc[];&#13;
&#13;
//Phong&#13;
out vec3 ViewDirection;&#13;
out vec3 fvObjectPosition;
out vec3 MVPos;
out vec3 Normal;
out vec3 TexCoord;
out vec3 tmp;

out float cylR1;
out float cylR2;
out vec3 cylDir;
out vec3 cylP0;
out vec3 cylP1;
out vec3 cylN0;
out vec3 cylN1;

uniform vec3 OSGCameraPosition;

#define mMVP gl_ModelViewProjectionMatrix
#define mMV gl_ModelViewMatrix
#define mP gl_ProjectionMatrix&#13;

vec4 crns[8];
vec4 crnsMV[8];
vec4 crnsMVP[8];
&#13;
void emit(int i) {&#13;
	gl_Position = crnsMVP[i];&#13;
	MVPos = crnsMV[i].xyz;
	fvObjectPosition = crnsMVP[i].xyz;&#13;
	ViewDirection = -fvObjectPosition.xyz;
	ViewDirection = normalize(ViewDirection);
&#13;
	/*vec4 p1 = gl_PositionIn[0];&#13;
	vec4 p2 = gl_PositionIn[1];
	vec3 d = normalize(p2.xyz - p1.xyz);
	TexCoord = p.xyz + 0.5 * d / (1.0+10*p.xyz);*/

	TexCoord = crns[i].xyz;
	TexCoord.y *= 0.15; // TODO: looks ugly!&#13;
	EmitVertex();&#13;
}&#13;
&#13;
void emitQuad(int i1, int i2, int i3, int i4) {&#13;
	vec4 mvp1 = crnsMVP[i1];
	vec4 mvp2 = crnsMVP[i2];
	vec4 mvp3 = crnsMVP[i3];
	vec4 mvp4 = crnsMVP[i4];
	
	// check visibility
	vec4 c = (mvp1+mvp3)*0.5;
	vec3 i = normalize( vec3(mvp2.xyz - mvp1.xyz) );
    vec3 j = normalize( vec3(mvp4.xyz - mvp1.xyz) );
    if ( dot(cross(i, j),c.xyz) &lt; 0.0 ) return;
&#13;
	emit(i1);
	emit(i2);
	emit(i4);
	emit(i3);&#13;
	EndPrimitive();&#13;
}

vec3 perp(vec3 v) {
    vec3 b = cross(v, vec3(1, 0, 0));
    if (dot(b, b) &lt; 0.01) b = cross(v, vec3(0, 0, 1));
    return b;
}
&#13;
void main() {&#13;
   vec4 p1 = gl_PositionIn[0];&#13;
   vec4 p2 = gl_PositionIn[1];
   vec4 pm = (p1+p2)*0.5;
   vec3 dir = p2.xyz - p1.xyz;
   
   // TODO: try to make the segment bigger.
   
   cylR1 = tc[0][0]*0.1;
   cylR2 = tc[1][0]*0.1;
   cylDir = normalize(vec3(mMV * vec4(dir,0.0)));
   cylP0 = vec3(mMV * p1);
   cylP1 = vec3(mMV * p2);
   cylN0 = cylDir;
   cylN1 = cylDir;
     
   vec4 Y = vec4(dir*0.5, 0.0);
   vec4 X = vec4( normalize(perp(dir)) ,0.0);
   vec4 Z = vec4( normalize(cross(dir, X.xyz)) ,0.0);&#13;
 
   crns[0] = pm - X*cylR1 - Y - Z*cylR1;
   crns[1] = pm + X*cylR1 - Y - Z*cylR1;
   crns[2] = pm + X*cylR1 - Y + Z*cylR1;
   crns[3] = pm - X*cylR1 - Y + Z*cylR1;
   crns[4] = pm - X*cylR1 + Y - Z*cylR1;
   crns[5] = pm + X*cylR1 + Y - Z*cylR1;
   crns[6] = pm + X*cylR1 + Y + Z*cylR1;
   crns[7] = pm - X*cylR1 + Y + Z*cylR1;
   
   for (int i=0; i&lt;8; i++) crnsMV[i] = mMV * crns[i];
   for (int i=0; i&lt;8; i++) crnsMVP[i] = mP * crnsMV[i];
   &#13;
   emitQuad(3, 2, 1, 0); // bottom
   emitQuad(4, 5, 6, 7); // top
   emitQuad(0, 1, 5, 4); // sides
   emitQuad(1, 2, 6, 5);
   emitQuad(2, 3, 7, 6);
   emitQuad(3, 0, 4, 7);&#13;
}





</core>
    </Script>
    <Script base_name="shrd_vert" name_space="__script__" name_suffix="0" persistency="666" unique="1" type="GLSL" mobile="">
      <core>
// vertex shader program
varying mat4 mMVv;
varying mat4 mPv;
varying vec2 vtc;
varying vec3 vn;&#13;
&#13;
attribute vec4 osg_Vertex;&#13;
attribute vec3 osg_Normal;
attribute vec2 osg_MultiTexCoord0;&#13;
&#13;
//----------------------------------------------------------------------------------------------MAIN--VP&#13;
void main( void ) {
	vtc = osg_MultiTexCoord0;
	vn = osg_Normal;&#13;
    gl_Position = osg_Vertex;
    mMVv = gl_ModelViewMatrix;
    mPv = gl_ProjectionMatrix;&#13;
}
</core>
    </Script>
  </Scripts>
  <Sockets persistency="666"/>
  <Background color="0.6 0.6 0.6" format=".png" path="" persistency="666" type="0"/>
  <Navigation active="Orbit" persistency="666"/>
  <Materials persistency="666"/>
  <Semantics persistency="666"/>
</Scene>
